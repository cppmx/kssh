#!/bin/bash
#
#

export PATH=$PATH:/usr/bin

# Load common functions
if [ ! -f ~/bin/kons_functions ]
then
   echo "~/bin/kons_functions not found or not readable. Exiting."
   exit 1
fi
. ~/bin/kons_functions
# Use function SetValue from common functions.

KONSOLE_PROFILES_TEMPLATES=~/.config/kssh/templates

if [ -f ~/.config/kssh/config.sh ]
then
    source ~/.config/kssh/config.sh
fi

if [ "$KONSOLE_PROFILES" = "" ] && [ -d $HOME/.local/share/konsole/ ]
then
   KONSOLE_PROFILES=.local/share/konsole/
fi
if [ "$KONSOLE_PROFILES" = "" ] && [ -d $HOME/.kde/share/apps/konsole ]
then
  KONSOLE_PROFILES=.kde/share/apps/konsole/
fi

if [ ! -d $HOME/$KONSOLE_PROFILES ]
then
   echo "Unable to find out konsole profile KONSOLE_PROFILES (in '$HOME' / '$KONSOLE_PROFILES'). You must install konsole and run it once to create profiles"
   exit 1
fi

function Help()
{
 echo "WARNING! This tool is better usable if you are using a private key without password or loaded by your ssh-agent. Otherwise, your will be prompted for your password, all the time.
Read documentation about generating keys (man ssh-keygen) and ssh-add (man ssh-add)

There is 8 ways to use this tool. This will be explained in details just below.
- 1. Query profiles
  $(basename $0) [--m [options]|--details [--format <sprintf format> <awk fields selection>]] [--sessions-open] [<Grep Filter>]
- 2. Execute remotely same command to several servers
  $(basename $0) <Grep Filter> [Several options] '<cmd>'
- 3. Download or upload same files from or to several remote servers.
  $(basename $0) <Grep Filter> <File1> [<file2> [...]] SERVER:<path>
  or
  $(basename $0) <Grep Filter> SERVER:<File1> [SERVER:<file2> [...]] <localpath>
- 4. export or import konsole profiles
  $(basename $0) <Grep Filter> --import [options]
  $(basename $0) <Grep Filter> --export [options]
  or
  $(basename $0) <Grep Filter> --import-data [options]
  $(basename $0) <Grep Filter> --export-data [options]
- 5. Change information associated to each profiles:
  $(basename $0) <Grep Filter> --update [options]
- 6. Delete one or more profile managed by $0 and/or konsole.
  There is 2 ways to removed profiles:
  Deleting from profile names (1) or from a query (2)
  6.1. From a list of profiles:
       $(basename $0) --delete <ProfileFile> [<Other profiles> ...]
  6.2. From a query :
       $(basename $0) <Grep Filter> --mass-delete
- 7. Excel/CSV data export
  $(basename $0) <Grep Filter> --extract [options]
- 7. konsole sessions collection management
  This command will help you to open sessions to several servers in parallel, automatically.
  $(basename $0) --collection <--open|--create|--remove|--add|--delete|--import|--export|--run> [options]

Details:
-------
[1m1. Query list of configured ssh konsole profiles:[0m
Syntax: $(basename $0) [Filter] [--m|--details [--format <sprintf format> <awk fields selection>]]

The Filter is based on grep syntax. Pleare refer to grep to get more details. (man grep)
For --format, the output uses printf function implemented in awk.
              See man printf to get information on format string syntax.
              The awk fields is a comma separated string, with list of awk variables. Usually, awk field is identified by a $ and a field number.
              But you cn put anything you need, like a calculated value, or function call. See functions and variables in awk man pages.

Ex: $(basename $0) PRO.*APP or $(basename $0)
This example, list all konsole session filter by \"PRO\" and \"APP\" or no filter.

    $(basename $0) \"-e BS.*PRO -e BS.*ITG\"
This example will show you all BS application, PRO or ITG servers selected.

    $(basename $0) \"-e BS.*PRO -e BS.*ITG\" --details
This example will show you all BS application, PRO or ITG servers selected in details. Note that the option '--details' can be set before the filter option
    $(basename $0) [1m--details[0m \"-e BS.*PRO -e BS.*ITG\"

[1m2. Execute same commands on several servers[0m
Syntax: $(basename $0) <Filter> [--silent|--go-on] [-i|--interactive|--highlight <string>] [--short] [--save_log <dir> [--no-output]] <Command> [Par1] [...]

Options are:
--silent | --go-on: This option will remove the need to confirm the list of servers selected thanks to your filter. Mostly used by cron/at jobs.

--interactive or -i:
  If your command will requires an interactive session (like shell, editor, ...) use the -i (or --interactive) to open as interactive session. These sessions will be opened in serial, one y one.
  If your command do not require any interactive session, all commands will be executed in parallel to boost getting the result.

--highlight [--color color_num] <string>:
  In case of non interactive session, you may need to highlight some results. Use this option to set a regular expression for sed to highlight them.
  With the optional [color_num], you can set a specific color for these strings. color are : By default, color are not set and the string will appear in light.
30	Black
31	Red
32	Green
33	Yellow
34	Blue
35	Magenta
36	Cyan
37	White

  You can use the short cuts like --Black instead or setting --highlight --color 30
  Only one highlight option per color_num are kept. If you set twice for the same color_num, the last one win.
--save_log <dir> [--no-output]:
  By default, the remote command is display directly to the output. If you need to keep this output in some files, use this option.
  Then add --no-output to remove their display to the output.

--short:
  By default, the output is written to the terminal in log format. You can use this option to get a short output limiting to the server name and the remote command execution output.

  This option can be used with save_log option.

- Executing 'ls' on all remote servers in parallel:
  Ex: $(basename $0) PRO --highlight --color 32 'data.txt\|toto.txt' ls
      This will list files for every PRO ssh sessions. All data.txt or toto.txt found will be highlighted in green. Please note the \| required by sed

  [1mWARNING[0m! if you use a command which will requires interactive access, your sessions may hang.

- Getting bash shell on all remote servers (in series)
  Ex: $(basename $0) PRO -i
      This will open the default shell, one by one. As soon as you are connected to one server, you will need to exit when done. Then $1 will open the next server.

      $(basename $0) PRO -i vi test.txt
      This will open vi to edit the 'test.txt', one by one. As soon as you are connected to one server, you will need to quit vi when done. Then $1 will open the next server.

[1m3. Execute an scp from or to the list of server. Use the special string 'SERVER:' to refer to each servers filtered.[0m
Syntax: $(basename $0) <Filter> [--silent] <File1> <File2> [File3 [...]]

Ex: $(basename $0) PRO MyFile SERVER:tmp/
    This command will copy MyFile to every server filtered by PRO to remote tmp directory

    $(basename $0) PRO SERVER:tmp/MyFile .
    This command will get MyFile from each remote tmp directory. Locally, you will receive SERVER_MyFile. SERVER string will be replace by the real server name where the files has been downloaded.

Options are:
--silent | --go-on: This option will remove the need to confirm the list of servers selected thanks to your filter. Mostly used by cron/at jobs.

[1m4. Export/Import konsole profiles for others (with scripts to use)[0m
There is 4 use cases: import, export, import-data and export-data.
 - Importing profiles from a package
   Syntax:
   $(basename $0) <Filter> --import <kons_profile_file> [--username <profiles_username>] [--autossh]

   This option will import the profiles stored in the kons_profile_file file.
   If the profile filename to be restored already exist, these profiles will be replaced otherwise it is added. Conflicts are shown.

   Ex: $(basename $0) '' --import kons_profiles.tar.gz --username gravley
   This command will import ALL (Filter = '') konsole profiles to your system.
   --username is optional. by default, it will be your Username ie $(id -un).

    $(basename $0) 'PERS' --import kons_profiles.tar.gz --autossh
   This command will import filtered PERS profiles to your system and will configure to use autossh if the command exist. By default, it is using direct ssh command.

 - Exporting profiles in a package.
   $(basename $0) <Filter> --export <exported_file>
   This command will export selected profiles.

   Ex: $(basename $0) BS2 --export ~/tmp/kons_profiles.tar.gz
   This command will export 'BS2' profiles thanks to your filter, ie BS2 in this exaple, and generates the 'exported_file', ie ~/tmp/kons_profiles.tar.gz

 - Importing data profiles from a PATH (Used from an SCM checkout for example)
   $(basename $0) <Filter> --import-data <PATH> [--username <profiles_username>] [--autossh]

 - Exporting data profiles to a PATH (Used to update an SCM checkout for example)
   This command will export profiles data from selected. This is useful to update and checked out SCM project, like svn.
   Note that filename are based on a convention.
   '<username or 'USER'>-<serverName>.dat'
   Syntax:
   $(basename $0) <Filter> --export-data <export directory>

[1m5. Change profiles information.[0m
Syntax:
$(basename $0) <Filter> --update [--noedit] [--app-code <app-code>] [--server <server>] [--user <user-name>] [--categ <categ>] [--role <role>] [--location <location>] [--autossh <y|n>] [--status <status>] [--comment <Comment>]
By default the command will show you data in text table, and you can edit it. Any change will be written, as soon as you save and quit.
Do not update the first column. Leading or trailing spaces will be suppressed for each column. So, you can update the file for readibility.

You can avoid editing it using --noedit and do a massive update.
=> At least one of 'app-code','server','user','categ','role','location','autossh','status','comment' have to be set in your list of parameters.

The following examples show this 2 different behaviors.

Ex: EDITOR=nedit $(basename $0) BS2.*NEW --update
This command will select BS2 NEW instance and will open 'nedit'. You will be able to update anything (except the first column). When done, save and quit. The command will go on and update. Each profile will be updated only if there is a update to provide to the profile.

Ex: $(basename $0) BS2.*CAN --update --comment 'sct140002.can.hp.com'
This command set the comment 'sct140002.can.hp.com' to 2 profiles in BS2, located in CAN.

[1m6. Create or Remove a named konsole profile[0m
Syntax:
$(basename $0) --delete|--add <profileName>
This is removing or adding just one profile at a time.

or

$(basename $0) <Filter> --mass-delete
This is removing all profiles selected by the query. A confirmation will be sent before starting the removal process.

[1m7. Extract profile information for Excel or any others application supporting the csv format.[0m
Syntax:
$(basename $0) <Filter> --extract <csv-file>
This will extract selected filtered profiles information and will generate a <csv-file> file. This format is CSV compatible.

[1m8. Sessions collection management.[0m
5 actions possible:
- create : Will create/update a session collection name which will be used to connect to several server, using --open.
  $(basename $0) --collection --create [-f] <collection_name> <filter>
  Specify -f to re-create an existing one. No warning printed.

- delete : Will delete a session collection name.
  $(basename $0) --collection --delete [-y] <collection_name> [...]
  Specify -y to force removing the collection. No warning printed.

- add    : Will add a konsole profile to an existing collection name.
  $(basename $0) --collection <collection_name> --add <profile name>

- remove : Will delete a session from the collection name.
  $(basename $0) --collection <collection_name> --remove  <profile name>

- open   : Will start a konsole window, and load all konsole sessions in tabs associated to the konsole session collection name.
  $(basename $0) --collection <collection_name> [--title-awkfmt 'Awk Instructions'] --open
  --title-awkfmt help to fix tabs title from sessions data.
  \$1 to \$12 are session information fields that can be used as followed:
  $(HelpDatStruct)

- run    : Will ssh a command or scp files from/to collection servers.
  $(basename $0) --collection <Collection> --run [RunOptions] (<command> [parameters] | <files> SERVER:<path> | SERVER:<file> <path>)
  <RunOptions> are those defined by 'Execute same commands on several servers' use case.

- import : Will import a kscz package (tar file containing several collections) to $(basename $0)
  $(basename $0) --collection --import <kscz FILE>

- export : Will export a list of collection filtered by <Collections FILTER>, saved under <kscz FileName without extension>
  $(basename $0) --collection --export <kscz FileName without extension> <Collections FILTER>

You can combine several options, like add or delete and open
Ex: $(basename $0) --collection BS_PRO_RCS --delete 'profile1' --delete 'profile2' --add 'profile3' --open
This will delete 2 profiles from test, add one, and open the collection by opening konsole and log to all profile located in the collection.
Another example:
Ex: $(basename $0) --collection BS_PRO_RCS.1 --open --collection BS_PRO_RCS.2 --open --collection --BS_PRO_NGDC --open
This will open 3 konsole windows 1 for each collection.

Extra parameters:
--version : To show out $(basename $0) script version.
" | more
}


function ssh_or_scp()
{
 FILTER_FILE="$1"
 shift

 # Get run related flags
 NEXTPAR=False
 SERVONLY=False
 DETAILS=False
 MACHINE_ONLY=False

 while [ $# -ne 0 ] && [ "$NEXTPAR" = False ]
 do
     if [ "$(echo "p$1" | cut -c1-2)" = "p-" ]
     then
          case "p$1" in
             "p--Black")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[30]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--Red")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[31]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--Green")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[32]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--Yellow")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[33]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--Blue")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[34]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--Magenta")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[35]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--Cyan")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[36]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--White")
                DETAILS=False
                INTER=FALSE
                MACHINE_ONLY=False
                shift
                HIGHLIGHT[37]="$1"
                HIGHLIGHT[0]=True
                shift
                ;;
             "p--highlight")
                shift
                if [ "p$1" = "p--color" ]
                then
                   shift
                   if [ "$1" -lt 30 ] || [ "$1" -gt 37 ]
                   then
                      echo "Color code are invalid. Use between 30 to 37"
                   else
                      HIGHLIGHT[$1]="$2"
                      HIGHLIGHT[0]=True
                   fi
                   shift
                else
                   HIGHLIGHT[1]="$1"
                   HIGHLIGHT[0]=True
                fi
                DETAILS=False
                INTER=False
                MACHINE_ONLY=False
                shift
                ;;
             "p--short")
                SUMMARY=False
                SHORT=True
                INTER=False
                shift
                ;;
             "p--summary")
                SUMMARY=True
                SHORT=False
                INTER=False
                shift
                ;;
             "p--go-on")
                GO_ON=True
                INTER=False
                shift
                ;;
             "p--silent")
                SILENT=True
                GO_ON=True
                INTER=False
                shift
                ;;
             *)
                NEXTPAR=True
                ;;
          esac
     else
        NEXTPAR=True
     fi
 done

 if [ "$(echo "$*" | grep SERVER: )" != "" ]
 then
    SCP=True
    if [ "$(echo "$PAR1" | grep SERVER:)" = "" ]
    then
       DIRECT="from"
    else
       DIRECT="to"
    fi
    if [ "$INTER" = 'True' ]
    then
       echo "You are going to [1mscp files $DIRECT[0m these servers."
    fi

 else
    SCP=False
    if [ "$GO_ON" != True ]
    then
       if [ "$INTER" = 'True' ]
       then
          echo "You are requesting to [1mhave interactive access[0m to these servers in series."
       else
          echo "You are going to [1mexecute remote commands[0m to these servers in parallel."
       fi
    fi
 fi
 if [ "$GO_ON" != True ]
 then
    echo "Please confirm, servers listed are correct before going on... Ctrl-C to interrupt."
    read
 fi

 # Preparing command options

 PAR_SAVED=""
 PAR1="$1"
 PAR2="$2"
 while [ $# -ne 0 ]
 do
   PAR_SAVED="$PAR_SAVED \"$1\""
   shift
 done

 # Preparing sed highlight feature (for parallel remote commands)
 TMPDIR=/tmp/$$_kons_exe
 if [ "${HIGHLIGHT[0]}" = "True" ]
 then
    mkdir -p $TMPDIR
    touch $TMPDIR/sed.cmd
    # Build the highlight sed string.
    for i in 1 30 31 32 33 34 35 36 37
    do
       if [ "${HIGHLIGHT[$i]}" != "" ]
       then
	  highlight_str="$( echo "${HIGHLIGHT[$i]}"| sed 's|/|\\/|g')"
          if [ $i -eq 1 ]
          then
             echo 's/\('"$highlight_str"'\)/[1m\1[0m/g' >> $TMPDIR/sed.cmd
          else
             echo 's/\('"$highlight_str"'\)/[1;'"$i"'m\1[0m/g' >> $TMPDIR/sed.cmd
          fi
       fi
    done
 fi


 NUM_SERVERS=$(cat $FILTER_FILE | wc -l)
 iCount=1
 while [ $iCount -le $NUM_SERVERS ]
 do
    LINE="$(awk '{if (FNR == '$iCount' ) print $0}' $FILTER_FILE)"
    let "iCount++"
    i="$( dat_extract USER_NAME       "$LINE")@$( dat_extract SERVER          "$LINE")"
    if [ "$SCP" = "False" ]
    then
       SSH="$( dat_extract CMD             "$LINE") -oStrictHostKeyChecking=no "
       SSH_OPTS="$( dat_extract CMD_OPTS   "$LINE")"
       # -------------------------------------------------------------------------------------------- ssh behavior.
       if [ "$INTER" = True ]
       then
          echo "You are entering to interactive session to $i in few seconds. Type exit when done to enter to the next one..."
          if [ "$PAR_SAVED" = "" ]
          then
             $SSH $SSH_OPTS $i
          else
             eval "$SSH -t $SSH_OPTS $i $PAR_SAVED"
          fi
       else
          ssh_add_rem_cmds "$i" "$SSH -o BatchMode=yes -Ctt $SSH_OPTS $i $PAR_SAVED"
       fi
       # --------------------------------------------------------------------------------------------
    else
       # -------------------------------------------------------------------------------------------- scp behavior.
       if [ "$(echo "$PAR1" | grep SERVER:)" = "" ]
       then
          PAR="$(echo "$PAR_SAVED" | sed 's/SERVER:/'$i':/g')"
       else
          if [ $NUM_SERVERS -gt 1 ]
          then
             if [ -d "$PAR2" ]
             then
                DEST="$PAR2"/$i-$(basename $PAR1)
             else
                DEST="$(dirname "$PAR2")/$i-$(basename $PAR2)"
             fi
          else
             DEST="$PAR2"
          fi
          PAR="$(echo \"$PAR1\" \"$DEST\" | sed 's/SERVER:/'$i':/g')"
       fi
       if [ "$SILENT" != True ]
       then
          echo "Starting : scp -p $PAR"
          (eval "scp -p $PAR";echo $i done) &
       else
          (eval "scp -qp $PAR") &
       fi
    fi
 done
 if [ "$SCP" = "True" ]
 then
    ps -aef | grep "[0-9] 'scp -p'"
    while [ "$(ps -aef | grep "[0-9] scp")" != "" ]
    do
       sleep 1
    done
    # --------------------------------------------------------------------------------------------
 else
    # Only execute if remote commands has been added.
    ssh_run
    ssh_show
 fi
}

function collection_mgt()
{
 COLLECTIONS_PATH=$HOME/$KONSOLE_PROFILES
 if [ -f "$COLLECTIONS_PATH/$1.ksc" ]
 then
    COLLECTION="$1"
    shift
 fi

 while [ $# -gt 0 ]
 do
    case "p$1" in
     "p--import")
       shift
       if [ $# -ge 1 ]
       then
          PWD_SAV="$(pwd)"
          TAR_FILE="$(basename "$1")"
          cp $1 $HOME/$KONSOLE_PROFILES
          if [ $? -eq 0 ]
          then
             cd $HOME/$KONSOLE_PROFILES
             tar -xvzf "$TAR_FILE"
             echo "Package $1 imported."
             rm -f  "$TAR_FILE"
          else
             echo "Package name not found. import ignored."
          fi
          shift
          cd "$PWD_SAV"
       else
          echo "Need a package name. import ignored."
       fi
       ;;
     "p--export")
       shift
       if [ $# -eq 2 ]
       then
          PWD_SAV="$(pwd)"
          TAR_PATH="$(dirname "$1")"
          TAR_FILE="$(basename "$1").kscz"
          FILTER="$2"
          cd $HOME/$KONSOLE_PROFILES
          eval "tar -cvzf '$TAR_FILE' $FILTER.ksc"
          cd "$PWD_SAV"
          mv $HOME/$KONSOLE_PROFILES"$TAR_FILE" "$TAR_PATH"
          echo "Package $1.kscz exported."
          exit
       else
          echo "Need a package name and a filter. Ex: $(basename $0) --collection test --export mytar 'BS1*'"
          exit
       fi
       ;;
     "p--list")
       shift
       if [ "$COLLECTION" = "" ]
       then
          echo "Collection name is not specified. Please add the collection name before the action."
          exit
       fi
       echo "List of profiles in '$COLLECTION':"
       cat "$COLLECTIONS_PATH/$COLLECTION.ksc"
       ;;
     "p--title-awkfmt")
       shift
       AWK_FMT="$1"
       shift
       ;;
     "p--open")
       shift
       if [ "$COLLECTION" = "" ]
       then
          echo "Collection name is not specified. Please add the collection name before the action."
          exit
       fi
       # Generating a tabs configuration file for console.
       > ~/.kons_tabs
       cat "$COLLECTIONS_PATH/$COLLECTION.ksc" | while read FILE
       do
          CMD="$(grep Command= "$FILE" | sed 's/Command=//g')"
          FILEDAT="$(echo "$FILE" | sed 's/\.profile/.dat/g')"
          if [ "$AWK_FMT" = "" ]
          then
             AWK_FMT='{ print $12}'
          fi
          if  [ -f "$FILEDAT" ]
          then
             PROFILE="$(eval "awk -F'|' '$AWK_FMT' \"$FILEDAT\"" | sed 's/\.profile//g')"
          else
             PROFILE="$(echo "$CMD" | sed 's/^.* \([a-z0-9]*@.*\)/\1/g')"
          fi
          echo "title:$PROFILE;;profile:$PROFILE" >> ~/.kons_tabs
       done
       konsole --tabs-from-file ~/.kons_tabs --new-tab
       sleep 1
       rm -f ~/.kons_tabs
       ;;
     "p--add")
       shift
       if [ "$COLLECTION" = "" ]
       then
          echo "Collection name is not specified. Please add the collection name before the action."
          exit
       fi
       if [ ! -f "$COLLECTIONS_PATH/$1.profile" ]
       then
          echo "Profile $1 is not found. Query kons_exe with --details to get the konsole profile name to add."
          exit
       fi
       PROFILE=$1
       shift
       if [ "$(grep "/$PROFILE.profile" "$COLLECTIONS_PATH/$COLLECTION.ksc")" != "" ]
       then
          echo "$PROFILE is already added."
          exit
       fi
       echo "$COLLECTIONS_PATH/$PROFILE.profile" >> "$COLLECTIONS_PATH/$COLLECTION.ksc"
       echo "$COLLECTION updated. Profile '$PROFILE' added."
       ;;
     "p--remove")
       shift
       if [ "$COLLECTION" = "" ]
       then
          echo "Collection name is not specified. Please add the collection name before the action."
          exit 1
       fi
       PROFILE="$1"
       if [ "$PROFILE" = "" ]
       then
          echo "A profile to remove from the collection $COLLECTION is required."
          exit 1
       fi
       if [ ! -f "$COLLECTIONS_PATH/$1.profile" ]
       then
          echo "Profile $1 is not found. Query kons_exe with --details to get the konsole profile name to delete."
          exit
       fi
       shift
       if [ "$(grep "/$PROFILE.profile" "$COLLECTIONS_PATH/$COLLECTION.ksc")" = "" ]
       then
          echo "$PROFILE is not in the collection."
          exit
       fi
       grep -v -e "/$PROFILE.profile" "$COLLECTIONS_PATH/$COLLECTION.ksc" > "$COLLECTIONS_PATH/$COLLECTION.ksc".new
       mv "$COLLECTIONS_PATH/$COLLECTION.ksc".new "$COLLECTIONS_PATH/$COLLECTION.ksc"
       echo "$COLLECTION updated. Profile '$PROFILE' deleted."
       ;;
     "p--delete")
       shift
       if [ "p$1" = "p-y" ]
       then
          YES_DEFAULT=True
          shift
       else
          YES_DEFAULT=False
       fi
       for COLLECTION in $*
       do
           if [ "${COLLECTION:1:1}" = "p-" ]
           then
              break
           fi
           shift
           if [ ! -f "$COLLECTIONS_PATH/$COLLECTION.ksc" ]
           then
              echo "$COLLECTION is not a known collection in $COLLECTIONS_PATH"
              continue
           fi
           if [ $YES_DEFAULT = False ]
           then
              echo "You are going to remove $COLLECTION collection. Type Yes to confirm."
              read ANS
              if [ "$ANS" != Yes ]
              then
                 continue
              fi
           fi
           rm -f "$COLLECTIONS_PATH/$COLLECTION.ksc"
           echo "$COLLECTIONS_PATH/$COLLECTION.ksc removed."
       done
       ;;
     "p--run")
       shift
       if [ "$COLLECTION" = "" ]
       then
          echo "Collection name is not specified. Please add the collection name before the action."
          exit
       fi
       CollectionFilter "$COLLECTIONS_PATH/$COLLECTION.ksc" True ~/.ssh_connection.dat
       sort_information ~/.ssh_connection.dat ~/.ssh_connection.data
       Details_output ~/.ssh_connection.data
       ssh_or_scp ~/.ssh_connection.dat "$@"
       exit
       ;;
     "p--create")
       shift
       if [ "p$1" = "p-f" ]
       then
          YES_DEFAULT=True
          shift
       else
          YES_DEFAULT=False
       fi

       if [ -f "$COLLECTIONS_PATH/$1.ksc" ] && [ $YES_DEFAULT = False ]
       then
          echo "$1 is a known collection in $COLLECTIONS_PATH. Replace it? Type Yes to replace."
          read ANSWER
       else
          ANSWER="Yes"
       fi
       if [ $# -lt 2 ]
       then
          echo "You need to provide the new collection name and a filter."
          exit
       fi
       COLLECTION=$1
       FILTER="$2"
       shift;shift
       if [ "$ANSWER" = "Yes" ]
       then
           #      PATH_SEARCH,      FILTER,   EXPORT_OUTPUT, DETAILS_OUTPUT, OUTPUT_FILE
          Filter  $COLLECTIONS_PATH "$FILTER" True           False           "$COLLECTIONS_PATH/$COLLECTION.ksc"
          echo "Collection $COLLECTION created with following profiles selected:"
          cat "$COLLECTIONS_PATH/$COLLECTION.ksc"
       else
          echo "$COLLECTION not created."
       fi
       echo
       ;;
     "p--show")
       shift
       if [ $# -eq 0 ]
       then
          echo "Collection management missing action."
          cd "$COLLECTIONS_PATH"
          echo "List of existing collections:"
          ls -1 *.ksc | sed 's/\.ksc//g'
          exit
       fi
       if [ "p$1" != "p--create" ] && [ "p$1" != "p--remove" ] && [ "p$1" != "p--import" ] && [ "p$1" != "p--export" ]
       then
          if [ ! -f "$COLLECTIONS_PATH/$1.ksc" ]
          then
             echo "$1 is not a known collection in $COLLECTIONS_PATH"
          exit
          fi
          COLLECTION=$1
          echo "Using collection $1"
          shift
       fi
       ;;

     *)
       echo "$1 is not a valid option. canceled."
       exit
       ;;
    esac
 done
 exit
}

####################################################################################################################
# MAIN
####################################################################################################################

if [ "$1" = "--help" ]
then
   Help
   exit
fi
if [ $# -eq 0 ]
then
   Help
echo "
--------------------------------------------------------------------------
Right now, all following session are queriable:

Press Enter to continue and get the complete list. Press Control-C to interrupt."
   read
   cat $HOME/$KONSOLE_PROFILES*.profile | grep "Name="
   exit
fi

NEXTPAR=False
SERVONLY=False
DETAILS=False
MACHINE_ONLY=False

while [ $# -ne 0 ] && [ "$NEXTPAR" = False ]
do
   OPTFOUND=False
   if [ "$(echo "p$1" | cut -c1-2)" = "p-" ]
   then
      case "p$1" in
        "p--version" )
            echo "$(basename $0) version 0.1"
            exit
            ;;
        "p--collection")
            shift
            if [ $# -eq 0 ]
                then
               collection_mgt --show
            else
                   collection_mgt "$@"
            fi
            exit
            ;;
        "p--servers-only" )
            SERVONLY=True
            OPTFOUND=True
            shift
            ;;
        "p--sessions-open" )
            OPTFOUND=True
            SESSIONS_OPEN=True
            shift
            ;;
        "p--details" )
            OPTFOUND=True
            DETAILS=True
            MACHINE_ONLY=False
            shift
            ;;
        "p--add")
            PROF_PATH=$HOME/$KONSOLE_PROFILES
            if [ -f $PROF_PATH/saved.dat ]
            then
               LINE="$(cat $PROF_PATH/saved.dat | grep -v -e '^#')"
            fi
            FORMAT="%4s|%15s|%4s|%4s|%4s|%7s|%30s|%25s|%15s|%s"

            APP_NAME="$( dat_extract APP_NAME  "$LINE")"
            NAME="$(     dat_extract NAME      "$LINE")"
            CATEG="$(    dat_extract CATEG     "$LINE")"
            ROLE="$(     dat_extract ROLE      "$LINE")"
            LOCATION="$( dat_extract LOCATION  "$LINE")"
            COMMENT="$(  dat_extract COMMENT   "$LINE")"
            SERVER="$(   dat_extract SERVER    "$LINE")"
            USER_NAME="$(dat_extract USER_NAME "$LINE")"
            CMD="$(      dat_extract CMD       "$LINE")"

            if [ "$USER_NAME" = "" ]
            then
               USER_NAME=$(id -un)
            fi
            if [ "$APP_NAME" = "" ]
            then
               APP_NAME="PERS"
            fi
            if [ "$CMD" = "" ]
            then
               CMD="ssh"
            fi

            DATA_TITLE="$(printf "$FORMAT\n" "#App" "Name" "Cat" "Role" "Loc" "Status" "Alias/Comments" "Server" "Account" "connect tool")"

            if [ "$2" = "" ]
            then
               FILEDAT="$PROF_PATH/prof.tmp"
            else
               PROFILE=$2
               FILEDAT="$(echo "$PROF_PATH/$PROFILE" | sed 's/\.profile$/.dat/g')"
               if [ "$(echo "$PROFILE" | grep '\.profile$')" = "" ]
               then
                  echo "Please add the extension .profile to your profile name."
                  exit
               fi
               if [ -f "$FILEDAT" ]
               then
                  echo "The profile '$PROFILE' already exist in '$PROF_PATH'. Choose a new one."
                  exit
               fi
               NAME="$(echo "$PROFILE" | sed 's/\.profile$//g')"
            fi
            echo "# Please update each column to create your profile. A server name is mandatory to create the profile." > $FILEDAT
            echo "#" >> $FILEDAT
            echo "# App : 4 Bytes - Define the profile application name relation." >> $FILEDAT
            echo "# Name : Define the profile name." >> $FILEDAT
            echo "# cat : 4 Bytes - Define the profile category name. Very common: PRO, ITG, DEV" >> $FILEDAT
            echo "# role : 4 Bytes - Define the profile role name. Very common: WEB, APP,..." >> $FILEDAT
            echo "# loc : 4 Bytes - Define the profile location name. Very common: HOU, IND, FTC, ..." >> $FILEDAT
            echo "# status : 6 Bytes - Define the profile status name. Usually refer to the server status in apate.." >> $FILEDAT
            echo "# alias/comment : Free text. Usually, we store the server alias name." >> $FILEDAT
            echo "# server : The real server name." >> $FILEDAT
            echo "# account : The account used to connect to the server name." >> $FILEDAT
            echo "# connect tool : The tool to connect to the remote server. ssh is the default. autossh is another example." >> $FILEDAT
            echo "#" >> $FILEDAT
            echo "$DATA_TITLE" >> $FILEDAT
            printf "$FORMAT" "$APP_NAME" "$NAME" "$CATEG" "$ROLE" "$LOCATION" "Created" "$COMMENT" "$SERVER" "$USER_NAME" "$CMD" >> $FILEDAT
            vim $FILEDAT
            LINE="$(cat $FILEDAT | grep -v -e '^#')"

            # Application|Name|Category|Role|Location|Status|Alias/Comments|server|Account|connection tool|Profile Path|Profile file
            APP_NAME="$( dat_extract APP_NAME   "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            NAME="$(     dat_extract NAME       "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            CATEG="$(    dat_extract CATEG      "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            ROLE="$(     dat_extract ROLE       "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            LOCATION="$( dat_extract LOCATION   "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            STATUS="$(   dat_extract STATUS     "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            COMMENT="$(  dat_extract COMMENT    "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            SERVER="$(   dat_extract SERVER     "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            USER_NAME="$(dat_extract USER_NAME  "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            CMD="$(      dat_extract CMD        "$LINE"| sed 's/^ *\([a-zA-Z0-9_-.]*\) *$/\1/g')"
            if [ "$SERVER" = "" ]
            then
               echo "Unable to create the profile, without at least a server name."
               exit 1
            fi
            if [ "$PROFILE" = "" ]
            then
               PROFILE="${USER_NAME}-${SERVER}.profile"
               FILEDAT="$(echo "$PROF_PATH/$PROFILE" | sed 's/\.profile$/.dat/g')"
            fi
            sed 's/NAME/'"$APP_NAME: $SERVER ($CATEG,$ROLE,$LOCATION)"'/g
                 s/CMD/'"$CMD -X -C $USER_NAME@$SERVER"'/g' $KONSOLE_PROFILES_TEMPLATES/template.profile.tpl > "$PROF_PATH/$PROFILE"

            echo "$APP_NAME|$NAME|$CATEG|$ROLE|$LOCATION|$STATUS|$COMMENT|$SERVER|$USER_NAME|$CMD|$PROF_PATH|$PROFILE" > $FILEDAT
            echo "$APP_NAME|$NAME|$CATEG|$ROLE|$LOCATION|$STATUS|$COMMENT|$SERVER|$USER_NAME|$CMD|$PROF_PATH|$PROFILE" > $PROF_PATH/saved.dat
            echo "$PROFILE created."
            exit
            ;;
         "p--m" )
            OPTFOUND=True
            DETAILS=False
            MACHINE_ONLY=True
            shift
            ;;
         "p--separator" | "p-s" )
            SEP="$2"
            if [ "p$SEP" = "p" ] || [ "$(echo "p$2" | cut -c1-2)" = "p-" ]
            then
               echo "Option error. $1 need a valid value. $2 is an invalid value. Exiting."
               exit
            fi
            shift
            shift
            ;;
         "p--delete")
             shift
             while [ "p$(echo "$1" | cut -c1)" != "p-" ] && [ $# -gt 0 ]
             do
                if [ -f $HOME/$KONSOLE_PROFILES"$1" ]
                then
                   echo "Press Enter to confirm the removal of '$1' or type 'n' to not remove it."
                   read ANS
                   if [ "$ANS" != "n" ] && [ "$ANS" != "N" ]
                   then
                      FILE="$(echo "$1" | sed 's/.profile$//g')"
                      rm -vf $HOME/$KONSOLE_PROFILES"$FILE".*
                   else
                      echo "$1 not removed."
                   fi
                else
                   echo "'$1' not found. Cannot remove."
                fi
                shift
             done
             exit
             ;;
      esac
      if [ "$OPTFOUND" != True ]
      then
         echo "Option $1 is not recognized. Check $0 --help"
         exit
      fi
   else
      NEXTPAR=True
   fi
done


# All following options or behaviors comes from a filter based.

FILTER="$1"

shift

NEXTPAR=False

while [ $# -ne 0 ] && [ "$NEXTPAR" = False ]
do
   OPTFOUND=False
   if [ "$(echo "p$1" | cut -c1-2)" = "p-" ]
   then
      case "p$1" in
         "p--mass-delete" )
            MASS_DELETE=True
            OPTFOUND=True
            shift
            ;;
         "p--interactive" | "p-i" )
            DETAILS=False
            INTER=True
            SILENT=False
            MACHINE_ONLY=False
            OPTFOUND=True
            shift
            ;;
         "p--format")
            shift
            if [ "$DETAILS" != True ]
            then
               echo "--format requires --details before."
               exit 1
            fi
            if [ "$1" = "" ] || [ "$2" = "" ]
            then
               echo "--format requires Format string (printf format) and fields number identified by $ and separated by commas (Ex: \$1,\$5, \$7). Awk string function is authorized. man awk for functions, or man printf for format."
               exit 1
            fi
            OUTPUT_FORMAT="$1"
            OUTPUT_FIELDS="$2"
            OPTFOUND=True
            shift
            shift
            ;;
         "p--save_log" )
            DETAILS=False
            INTER=False
            MACHINE_ONLY=False
            OPTFOUND=True
            shift
            if [ ! -e "$1" ] && [ -d "$(dirname $1)" ] && [ -w "$(dirname $1)" ]
            then
               echo "Creating $1..."
               mkdir $1
               if [ "$?" -ne 0 ]
               then
                  echo "Unable to create $1. Aborting."
                  exit 1
               fi
            fi
            if [ ! -d "$1" ] && [ ! -w "$1" ]
            then
               echo "$1 is not a writable directory. Please check. Aborting."
               exit 1
            fi
            SAVE_LOG="$(cd $1 ; pwd)"
            shift
            if [ "p$1" = "p--no-output" ]
            then
               shift
               NO_OUTPUT=True
            fi
            ;;
         "p--m" )
            OPTFOUND=True
            DETAILS=False
            MACHINE_ONLY=True
            shift
            ;;
         "p--separator" | "p-s" )
            SEP="$2"
            if [ "p$SEP" = "p" ] || [ "$(echo "p$2" | cut -c1-2)" = "p-" ]
            then
               echo "Option error. $1 need a valid value. $2 is an invalid value. Exiting."
               exit
            fi
            shift
            shift
            ;;
         "p--servers-only" )
              OPTFOUND=True
              SERVONLY=True
              shift
              ;;
          "p--sessions-open" )
              OPTFOUND=True
              SESSIONS_OPEN=True
              shift
              ;;
          "p--details" )
              OPTFOUND=True
              DETAILS=True
              MACHINE_ONLY=False
              shift
              ;;
# ---------------------------------------------------------------------------------- Export data
# ---------------------------------------------------------------------------------- Export
         "p--export-data" | "p--export")
           # Export dat files
           if [ "p$1" = "p--export" ]
           then
              EXPORT_PKG=True
              DAT_EXPORT=/tmp/$(basename "$2"| sed 's/.[a-zA-Z]*$//g')
              PCK_NAME="$(basename $2)"
              EXPORT_PATH=$(cd $(dirname "$2") ; pwd)
              mkdir -p "$DAT_EXPORT"
           else
              EXPORT_PKG=False
              DAT_EXPORT="$2"
           fi
           shift
           if [ ! -d "$DAT_EXPORT" ]
           then
              echo "$DAT_EXPORT does not exist as a directory. Please create it first."
              exit
           fi
           DAT_EXPORT="$(cd "$DAT_EXPORT" ; pwd)"
           Filter $HOME/$KONSOLE_PROFILES "$FILTER" False True ~/.ssh_connection.dat
           sort_information ~/.ssh_connection.dat ~/.ssh_connection.dats
           Details_output ~/.ssh_connection.dats
           echo "Please verify listed data and confirm it in pressing Enter key. Press Ctrl-C to interrupt."
           read
           cd $HOME/$KONSOLE_PROFILES

           # Copy dat files to DAT_EXPORT
           cat ~/.ssh_connection.dat | while read LINE
           do
              USER_NAME=$(dat_extract USER_NAME "$LINE" | sed 's/'"$USER"'/USER/g')
              SERVERNAME=$(dat_extract SERVER   "$LINE")
              LINE="$(dat_update PROFILE_FILE $USER_NAME-$SERVERNAME.profile "$LINE")"
              echo "$LINE" | sed 's/'"$USER"'/USER/g
                                  s/autossh -M *[0-9]*/ssh/g
                                  s/ssh-proxy/ssh/g' > "$DAT_EXPORT"/$USER_NAME-$SERVERNAME.dat
           done
           echo "Data profiles exported in $DAT_EXPORT."
           rm -f ~/.ssh_connection.dat ~/.ssh_connection.dats
           if [ $EXPORT_PKG = True ]
           then
              cd "$DAT_EXPORT"
              tar -czf "$EXPORT_PATH/$PCK_NAME" .
              echo "$EXPORT_PATH/$PCK_NAME has been created."
              cd
              rm -fr "$DAT_EXPORT"
           fi
           exit
           ;;
# ---------------------------------------------------------------------------------- Import-data
# ---------------------------------------------------------------------------------- Import
          "p--import-data" | "p--import")
           if [ "p$1" = "p--import" ]
           then
              IMPORT_PKG=True
              PCK_FILE="$(basename "$2")"
              FULL_PKG_PATH="$(cd $(dirname "$2") ; pwd)"
              EXPORTED_PATH="/tmp/$PCK_FILE"
              mkdir -p "$EXPORTED_PATH"
              if [ ! -d "$EXPORTED_PATH" ]
              then
                 echo "Unable to expand $PCK_FILE temporary to $EXPORTED_PATH. Aborted."
                 exit 1
              fi
              pushd "$EXPORTED_PATH" >/dev/null
              echo "Expanding $PCK_FILE..."
              tar -xzf "$FULL_PKG_PATH/$PCK_FILE"
              shift
              popd >/dev/null
           else
              IMPORT_PKG=False
              shift
              EXPORTED_PATH="$1"
           fi
            shift
            if [ ! -d "$EXPORTED_PATH" ]
            then
               echo "$EXPORTED_PATH is not a directory. Please use an exported directory where you have exported profiles data."
               exit
            fi
            if [ "p--username" = "p$1" ]
            then
               USER="$2"
               shift;shift
            fi
            if [ "$USER" = "" ]
            then
               USER="$(id -un)"
            fi
            if [ "p--ssh-proxy" = "p$1" ]
            then
               shift
               echo "Warning --ssh-proxy is now unsupported. For proxying, use the config file of ssh with Host and ProxyCommand and the binary nc."
            fi
            if [ "p--autossh" = "p$1" ]
            then
               shift
               which autossh 2>/dev/null 1>/dev/null
               SSH=''
               if [ $? -ne 0 ]
               then
                  echo "autossh not found. will use ssh instead."
               else
                  SSH='autossh'
                  echo "Using autossh instead of ssh for CMD."
               fi
            fi
            Filter "$EXPORTED_PATH" "$FILTER" False True .ssh_connection.lst
            sort_information .ssh_connection.lst .ssh_connection.data
            Details_output .ssh_connection.data
            echo "Please verify the previous list. These profiles will be configured with $USER account.
Press Enter to import these profiles to your konsole. Or Ctrl-C to interrupt."
            read
            echo "Importing..."
            FILTER_IMPORT="$FILTER"
            Filter $HOME/$KONSOLE_PROFILES "" False True .ssh_connection.lst-orig
            cat .ssh_connection.lst | sed 's/USER/'"$USER"'/g'"$SSH_PROXY" | while read LINE
            do
                SERVER="$(dat_extract SERVER "$LINE")"
                USERNAME="$(dat_extract USER_NAME "$LINE")"
                PROFILE="$(dat_extract PROFILE_FILE "$LINE")"

                FOUND="$(awk -F"|" '$8 ~ /'"$SERVER"'/ && $9 ~ /'"$USERNAME"'/ { print $0 }' .ssh_connection.lst-orig)"

                if [ "$FOUND" != "" ]
                then
                   # Updating existing profile
                   PROFILE_NAME="$(dat_extract PROFILE_FILE "$FOUND")"
                   [ "$PROFILE_NAME" != "$PROFILE" ] && echo "'$PROFILE' data import to '$PROFILE_NAME'"
                else
                   PROFILE=${USER}_$SERVER.profile
                   echo "New profile: $PROFILE"
                   PROFILE_NAME="$PROFILE"
                fi
                LINE="$(dat_update PROFILE_FILE "$PROFILE_NAME" "$LINE")"
                LINE="$(dat_update USER_NAME "$USER" "$LINE")"
                LINE="$(dat_update PROFILE_PATH "$KONSOLE_PROFILES" "$LINE")"
                CreateProfile True True "" "$LINE" "$SSH"
            done
            echo "Verification:"
            Filter $HOME/$KONSOLE_PROFILES "$FILTER_IMPORT" False True .ssh_connection.lst
            sort_information .ssh_connection.lst .ssh_connection.data
            Details_output .ssh_connection.data
            rm -f .ssh_connection.*
            if [ $IMPORT_PKG = True ] && [ -d "/tmp/$PCK_FILE" ]
            then
               rm -fr "/tmp/$PCK_FILE"
            fi
            exit
            ;;
# ---------------------------------------------------------------------------------- Extract
         "p--extract")
           shift
           CSV_extract "$1" "$FILTER"
           exit
           ;;
# ---------------------------------------------------------------------------------- Update
         "p--update")
           dat_edit $HOME/$KONSOLE_PROFILES "$FILTER" True "$@"

           DETAILS="True"
           OPTFOUND=True
	   break
           ;;
      esac
      if [ "$OPTFOUND" != True ]
      then
         echo "Option $1 is not recognized. Check $0 --help"
         exit
      fi
   else
      NEXTPAR=True
   fi
done


# ------------------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------- Query, ssh or scp behavior.
# ------------------------------------------------------------------------------------------------------------------------

if [ "$SESSIONS_OPEN" = True ]
then
   # -------------------------------------------------------------------------------------------- Open sessions
   > ~/.kons_tabs
   Filter $HOME/$KONSOLE_PROFILES "$FILTER" False True ~/.ssh_connection.lst
   sort_information ~/.ssh_connection.lst ~/.ssh_connection.data
   Details_output ~/.ssh_connection.data
   echo "Do you confirm to start previously listed konsole sessions? (Ctrl-C to stop it.)"
   read
   cat ~/.ssh_connection.lst | while read LINE
   do
      APP_NAME="$( dat_extract APP_NAME       "$LINE")"
      CATEG="$(    dat_extract CATEG          "$LINE")"
      ROLE="$(     dat_extract ROLE           "$LINE")"
      LOCATION="$( dat_extract LOCATION       "$LINE")"
      COMMENT="$(  dat_extract COMMENT        "$LINE")"
      SERVER="$(   dat_extract SERVER         "$LINE")"
      USER_NAME="$(dat_extract USER_NAME      "$LINE")"
      CMD="$(      dat_extract CMD            "$LINE")"
      PROF_PATH="$(dat_extract PROFILE_PATH   "$LINE")"
      PROFILE="$(  dat_extract PROFILE_FILE   "$LINE")"

      COMMAND="$CMD -X -C $USER_NAME@$SERVER"
      PROFILE="$(echo "$LINE" | awk -F"|" '{ print $7}' )"
      echo "title:$APP_NAME-$SERVER;;command:$COMMAND" >> ~/.kons_tabs
   done
   konsole --tabs-from-file ~/.kons_tabs
   sleep 1
   rm -f ~/.kons_tabs
   exit
fi

if [ "$MASS_DELETE" = "" ] && [ "$INTER" != True ] && ( [ "$1" = "" ] || [ "$DETAILS" = "True" ] || [ "$MACHINE_ONLY" = "True" ] )
then # Simple Query
   # Filtering
   Filter $HOME/$KONSOLE_PROFILES "$FILTER" False $DETAILS ~/.ssh_connection.lst
   # -------------------------------------------------------------------------------------------- Query
   if [ "$DETAILS" = "True" ]
   then
      sort_information ~/.ssh_connection.lst ~/.ssh_connection.data
      if [ "$OUTPUT_FORMAT" = "" ] || [ "$OUTPUT_FIELDS" = "" ]
      then
         Details_output ~/.ssh_connection.data
      else
         awk -F"|" '{ printf "'"$OUTPUT_FORMAT"'",'"$OUTPUT_FIELDS"' }' ~/.ssh_connection.data
         echo
      fi
   else
      dat_servers_list "$MACHINE_ONLY" ~/.ssh_connection.lst "$SEP"
   fi
   # --------------------------------------------------------------------------------------------
else
   # -------------------------------------------------------------------------------------------- delete, ssh or scp behavior.
   # Filtering
   Filter $HOME/$KONSOLE_PROFILES "$FILTER" False True ~/.ssh_connection.dat
   sort_information ~/.ssh_connection.dat ~/.ssh_connection.data
   if [ "$GO_ON" != True ]
   then
      Details_output ~/.ssh_connection.data
   fi
   if [ "$MASS_DELETE" = "True" ]
   then
      # ------------------------------------------------------------------------------------------ delete
      NUM_SERVERS=$(cat ~/.ssh_connection.dat | wc -l)
      if [ "$NUM_SERVERS" -eq 0 ]
      then
         echo "No profiles selected for removal. Exiting."
         exit
      fi
      echo "Press Enter to confirm the removal of these $NUM_SERVERS profiles or type 'n' to not remove it."
      read ANS
      if [ "$ANS" != "n" ] && [ "$ANS" != "N" ]
      then
         iCount=1
         while [ $iCount -le $NUM_SERVERS ]
         do
            LINE="$(awk '{if (FNR == '$iCount' ) print $0}' ~/.ssh_connection.dat)"
            let "iCount++"
            FILE="$(dat_extract PROFILE_FILE "$LINE" | sed 's/\.profile//g')"
            rm -vf $HOME/$KONSOLE_PROFILES"$FILE".*
         done
      fi
      exit
      # ------------------------------------------------------------------------------------------
   fi

   ssh_or_scp ~/.ssh_connection.dat "$@"
fi
if [ "$TMPDIR" != "" ]
then
   rm -fr "$TMPDIR"
fi

